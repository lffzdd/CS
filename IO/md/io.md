## 文件分为文本文件和二进制文件

1. 文本文件:只包含ASCII字符或Unicode字符
2. 其他文件全是二进制文件,音频,图像,目标文件...
   内核眼里都一样

## 文件类型:

![alt text](image.png)

## UNIX的I/O接口:

![alt text](image-1.png)

## 文件元数据

![alt text](image-2.png)

## stat
![alt text](image-3.png)

## 共享文件
- 描述符表 (descriptor table) 。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的 。每个打开的描述符表项指向文件表中的一个表项。
- 文件表 (file table) 。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数(reference count) (即当前指向该表项的描述符表项数），以及一个指向v-node 表中对应表项的指针 。 关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。
- v-node 表 (v- node table) 。同文件表一样，所有的进程共享这张 v- node 表 。每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员。

![alt text](image-4.png)
所以文件表的每个表项不是唯一的,不同文件表项可能指向同一个文件,只是文件位置不同

如图 10-13 所示，多个描述符也可以通过不同的文件表表项来引用同一个文件。例如，如果以同一个 filename 调用 open 函数两次，就会发生这种情况。关键思想是每个描述符都有它自己的文件位置，所以对不同描述符的读操作可以从文件的不同位置获取数据。
![alt text](image-5.png)

我们也能理解父子进程是如何共享文件的。假设在调用 fork 之前，父进程有如图 10-12 所示的打开文件。然后，图10-14 展示了调用 fork 后的情况。子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件表集合，因此共享相同的文件位置。一个很重要的结果就是，在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。
![alt text](image-6.png)

---
>*我有个疑问,read函数有一个文件读写指针,那么该指针的指向是根据文件表中表项的文件位置决定的,还是由内核代码记录的?*
>在 UNIX/Linux 系统中，读写指针（文件偏移量）是存储在文件表（file table）中对应表项里的。也就是说，每个打开的文件在文件表中都有一项，其中包含当前的文件位置。内核在调用 read、write 等系统调用时，会利用这个文件表项中的文件位置进行操作，并在操作后更新该位置。
>因此，这个指针既不是由文件描述符表直接决定的，也不是内核在其他地方独立记录的，而是内核通过文件表项来跟踪的。

---

## IO 重定向
dup2 函数复制描述符表表项 oldfd 到描述符表表项 newfd,覆盖描述符表表项 new­fd 以前的内容。如果 newfd 已经打开了，dup2 会在复制 oldfd 之前关闭 newfd 。假设在调用 dup2(4,1) 之前，我们的状态如图10-12 所示，其中描述符 1( 标准输出）对应千文件 AC 比如一个终端），描述符 4 对应于文件 BC 比如一个磁盘文件）。A 和 B 的引用计数都等于1 。图10-15 显示了调用 dup2(4,1) 之后的情况。两个描述符现在都指向文件 B;文件 A 已经被关闭了，并且它的文件表和 v-node 表表项也已经被删除了；文件 B的引用计数已经增加了。从此以后，任何写到标准输出的数据都被重定向到文件 B 。
![alt text](image-7.png)

## 标准I/O
![alt text](image-8.png)
既然 C标准库提供了带缓冲的I/O,那么为什么还要实现RIO呢?
这是因为标准I/O库虽然非常适合对终端或文件执行I/O操作,但不太适用于网络连接,它不是为网络连接设计的,所以不好用
因此RIO函数主要是用于网络连接
此外，带缓冲的I/O与RIO不能很好地共存,因为它们各自有自己的缓冲区，彼此之间互不了解,还会相互干扰,所以在对某个I/O连接进行操作时，你只能二选一,切忌混用

## 推荐书籍
![alt text](image-9.png)